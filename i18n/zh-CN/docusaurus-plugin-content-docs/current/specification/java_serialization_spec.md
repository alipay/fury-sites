---
title: Apache Fury Java 序列化格式
sidebar_position: 1
id: fury_java_serialization_spec
---

## 规范概述

Apache Fury Java 是一个支持引用和多态性的自动对象序列化框架。Apache Fury 将 Java 对象在序列化二进制数据和对象之间互相转换。Apache Fury 有两个用于 Java 序列化的核心概念：

- **Apache Fury Java 二进制格式**
- **对象和 Apache Fury Java 二进制序之间的格式**

序列化格式是动态的二进制格式。动态、引用/多态性支持使 Apache Fury 更加灵活，

更易于使用，与静态序列化框架相比，也引入了更多复杂性。因此格式将更加复杂。

整体格式如下：

```
| fury 标头 | 对象引用元数据 | 对象类元数据 | 对象值数据 |
```

当字节交换对于某些对象来说成本较高时，数据整体使用小端字节顺序进行序列化。

Apache Fury 会将该对象的字节顺序写入数据，而不是将其转换为小端。

## Apache Fury 标头

Apache Fury 标头由一个字节组成：

```
| 4 bit | 1 bit | 1 bit | 1 bit | 1 bit | 可选 4 个字节 |
+---------------+-------+----------+--------+-------+------------------------------------+
| 保留位 | oob | xlang | endian | null | 元起始偏移量的无符号整数 |
```

- null 标志：当对象为 null 时为 1，否则为 0。如果对象为 null，则不会设置其他位。
- endian 标志：当数据以小端编码时为 1，大端编码时为 0。
- xlang 标志：当序列化使用 xlang 格式时为 1，当序列化使用 Apache Fury java 格式时为 0。
- oob 标志：当传递的 `BufferCallback` 不为 null 时为 1，否则为 0。

如果启用了元共享模式，则会附加一个未压缩的无符号整数来指示元数据的起始偏移量。

## 引用元数据

引用跟踪处理对象是否为空，以及是否通过写入相应标志和维护内部状态来跟踪对象的引用。

引用标志：​​

| 标志 | 字节值 | 描述 |
|---------------------|------------|-----------------------------------------------------------------------------------------------------------------------------------------------------|
| NULL 标志 | `-3` | 此标志表示对象为空值。我们不使用另一个字节来指示 REF，这样我们可以节省一个字节。|
| REF 标志 | `-2` | 此标志表示对象之前已经序列化，fury 将以无符号 varint 格式写入 ref id，而不是再次序列化它 |
| NOT_NULL 值标志 | `-1` | 此标志表示对象为非空值，fury 不跟踪此类型对象的 ref。|
| REF 值标志 | `0` | 此标志表示对象可引用且是第一次序列化。|

当全局或针对特定类型或特定上下文中的某些类型（例如，类的字段）禁用引用跟踪时，只有 `NULL` 和 `NOT_NULL VALUE` 标志才会用于引用元数据。

## 类元数据

Apache Fury 支持通过可选 ID 注册类，注册功能可用于安全检查和类识别。

如果类已注册，它将具有用户提供的或自动增长的无符号整数，即 `class_id`。

根据当前类是否启用元共享模式和注册，Apache Fury 将以不同的方式写入类元。

### Schema 一致

如果全局启用 schema 一致模式或为当前类启用，类元将按以下方式写入：

- 如果类已注册，它将被写为 fury 无符号 varint：`class_id << 1`。
- 如果类未注册：
- 如果类不是数组，fury 将首先写入一个字节 `0bxxxxxxx1`，然后写入类名。
- 第一个小位是 `1`，与编码类 ID 的第一位 `0` 不同。Apache Fury 可以使用此信息来确定是否通过类 ID 读取类以进行反序列化。
- 如果未注册类且类是数组，fury 将首先写入一个字节 `dimensions << 1 | 1`，然后写入
component
类。如果组件类是或将被序列化，这可以减少数组类名成本。
- 默认情况下，类将写为两个枚举 fury 无符号：`package name` 和 `class name`。如果启用了 meta share
模式，
class 将写为指向 `MetaContext` 中索引的无符号 varint。

### Schema 演变

> 此模式将禁止流式写入，因为它需要在整个对象图写入和元信息收集完成后回头更新起始偏移量。只有这样，我们才能确保反序列化失败不会丢失共享的元信息。
> 未来将支持元流线化，以实现不跨越不同对象的多个序列化的封闭元共享。

对于 Schema 一致模式，类将通过完整类名编码为枚举字符串。这里我们主要描述 Schema 演进模式的元布局：

```
| 8 字节元标头 | 元大小 | 变量字节 | 变量字节 | 变量字节 |
+-------------------------------+-----------|--------------------+-----------------------+----------------+
| 7 字节哈希 + 1 字节标头 | 1~2 字节 | 当前类元 | 父类元 | ... |
```

类元信息从父类编码到叶类，只有具有可序列化字段的类才会被编码。

### Meta 标头

Meta 标头是一个按小端顺序编码的 64 位数字值。

- 最低 4 位 `0b0000~0b1110` 用于记录类数。`0b1111` 被保留以指示 Apache Fury 需要
使用 Apache Fury 无符号整数编码读取更多字节以获取长度。如果当前类没有父类，或者父类没有要序列化的字段，或者我们处于仅序列化当前类字段的上下文中（`ObjectStreamSerializer#SlotInfo` 就是一个例子），则类数将为 1。
- 第 5 位用于指示此类是否需要架构演化。
- 第 6 位用于指示所有层元数据的大小总和是否小于 256。
- 其他 56 位用于存储`标志 + 所有层类元数据`的唯一哈希值。

### 元大小

- 如果所有层元的大小总和小于 256，则接下来写入一个字节以指示元的长度。
- 否则，以小端序将大小写入两个字节。

### 单层类元

```
| 无符号 varint | 元字符串 | 元字符串 | 字段信息：可变字节 | 可变字节 | ... |
+----------------------------------------+-----------------------+---------------------+-------------------------------------------+-----------------+-----+
| 字段数 + 注册标志 | 标头 + 包名称 | 标头 + 类名称 | 标头 + 类型 ID + 字段名称 | 下一个字段信息 | ... |
```

- 字段数：将 `字段数 << 1 | 注册标志（类注册时为 1）` 编码为无符号 varint。
- 如果类已注册，则接下来将写入无符号 varint 类 ID，包和类名称将被省略。
- 如果当前类与架构一致，则 num 字段将为 `0` 以标记它。
- 如果当前类与架构不一致，则 num 字段将是兼容字段的数量。例如，
用户
可以使用标签 ID 在架构一致的上下文中将某些字段标记为兼容字段。在这种情况下，将首先序列化架构一致的字段，然后序列化兼容字段。在反序列化时，Apache Fury 将使用未通过标签 id 注释的字段的字段信息来反序列化架构一致的字段，然后使用 meta 中的字段信息来反序列化兼容字段。
- 包名称编码（注册类时省略）：
- 编码算法：`UTF8/ALL_TO_LOWER_SPECIAL/LOWER_UPPER_DIGIT_SPECIAL`
- 标头：`6 位大小 | 2 位编码标志`。`6 位大小：0~63` 将用于指示大小`0~62`，
值`63` 表示大小需要更多字节来读取，接下来编码将`size - 62` 编码为 varint。
- 类名编码（类注册时省略）：
- 编码算法：`UTF8/LOWER_UPPER_DIGIT_SPECIAL/FIRST_TO_LOWER_SPECIAL/ALL_TO_LOWER_SPECIAL`
- 标头：`6 位大小 | 2 位编码标志`。`6 位大小：0~63` 将用于指示大小`1~64`，
值`63` 大小需要更多字节才能读取，编码将把`size - 63` 编码为下一个 varint。
- 字段信息：
- 标头（8
位）：`3 位大小 + 2 位字段名称编码 + 多态性标志 + 可空性标志 + 引用跟踪标志`。
用户可以使用注释来提供这些信息。
- 2 位字段名称编码：
- 编码：`UTF8/ALL_TO_LOWER_SPECIAL/LOWER_UPPER_DIGIT_SPECIAL/TAG_ID`
- 如果使用标签 ID，即字段名称由无符号 varint 标签 ID 写入。2 位编码将为 `11`。
- 字段名称的大小：
- `3 位大小：0~7` 将用于指示长度 `1~7`，值 `6` 表示读取更多字节的大小，
编码将接下来将 `size - 7` 编码为 varint。
- 如果编码为 `TAG_ID`，则字段名称的 num_bytes 将用于存储标签 ID。
- 引用跟踪：设置为 1 时，将为此字段启用引用跟踪。
- 可空性：设置为 1 时，此字段可以为空。
- 多态性：设置为 1 时，即使字段类型不是 `final`，字段的实际类型也将是声明的字段类型。
- 类型 ID：
- 对于已注册的类型一致的类，它将是已注册的类 ID。
- 否则，如果不是 `final`，它将被编码为 `OBJECT_ID`，如果是 `final`，它将被编码为 `FINAL_OBJECT_ID`。此类类型的元是单独编写的，而不是在这里内联，这是为了减少元空间成本，如果此类型的对象在当前对象图中多次序列化，并且字段值也可能为空。
- 字段名称：如果设置了类型 ID，则将改用类型 ID。否则，将改为写入元字符串编码长度和数据。
字段顺序作为实现细节保留，未公开给规范，反序列化需要根据 Apache Fury 字段比较器对字段进行排序。这样，fury 可以计算字段名称或类型的统计信息，并使用更紧凑的编码。

### 其他层类元

编码算法与上一层相同，但以下情况除外：

- 标头 + 包名：
- 标头：
- 如果包名之前已经写过：将写入 `varint index + sharing flag(set)`
- 如果包名之前没有写过：
- 如果元字符串编码为 `LOWER_SPECIAL` 且编码字符串的长度 `<=` 64，则标头将为
`6 位大小 + 编码标志（设置）+ 共享标志（未设置）`。
- 否则，标头将为
`3 位未设置 + 3 位编码标志 + 编码标志（未设置）+ 共享标志（未设置）`

## 元字符串

元字符串主要用于对类名和字段名等元字符串进行编码。

### 编码算法

字符串二进制编码算法：

| 算法 | 模式 | 说明 |
|---------------------------|---------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| LOWER_SPECIAL | `a-z._$\|` | 每个字符使用 5 位写入，`a-z`: `0b00000~0b11001`，`._$\|`: `0b11010~0b11101`，在开头添加一位以指示自最后一个字节以来剥离最后一个字符是否有 7 个冗余位（1 表示剥离最后一个字符）|
| LOWER_UPPER_DIGIT_SPECIAL | `a-zA-Z0~9._` |每个字符使用 6 位写入，`a-z`: `0b00000~0b11001`，`A-Z`: `0b11010~0b110011`，`0~9`: `0b110100~0b111101`，`._`: `0b111110~0b111111`，在开头添加一位以指示是否从最后一个字节开始剥离最后一个字符可能有 7 个冗余位（1 表示剥离最后一个字符）|
| UTF-8 | 任何字符 | UTF-8 编码 |

编码标志：

| 编码标志 | 模式 | 编码算法 |
|---------------------------|-------------------------------------------------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------|
| LOWER_SPECIAL | 每个字符都在 `a-z._$\|` 中 | `LOWER_SPECIAL` |
| FIRST_TO_LOWER_SPECIAL | 除了第一个字符是大写之外，每个字符都是 `a-z[c1,c2]` | 将第一个大写字符替换为小写，然后使用 `LOWER_SPECIAL` |
| ALL_TO_LOWER_SPECIAL | 每个字符都是 `a-zA-Z[c1,c2]` | 将每个大写字符替换为 `\|` + `小写`，然后使用 `LOWER_SPECIAL`，如果它小于编码 `LOWER_UPPER_DIGIT_SPECIAL`，则使用此编码 |
| LOWER_UPPER_DIGIT_SPECIAL | 每个字符都是 `a-zA-Z[c1,c2]` | 如果小于编码 `FIRST_TO_LOWER_SPECIAL`，则使用 `LOWER_UPPER_DIGIT_SPECIAL` 编码 |
| UTF8 | 任何 utf-8 字符 |使用 `UTF-8` 编码 |
| 压缩 | 任何 utf-8 字符 | 无损压缩 |

备注：

- 对于包名称编码，`c1,c2` 应为 `._`；对于字段/类型名称编码，`c1,c2` 应为 `_$`；
- 根据情况，可以选择联合编码 `flags + data`，使用第一个字节的 3 位作为标志，其他字节作为数据。

### 共享元字符串

共享元字符串格式由标头和编码字符串二进制组成。编码字符串二进制的标头将内联在共享元标头中。

标头使用小端顺序写入，Apache Fury 可以首先读取此标志以确定如何反序列化数据。

#### 按数据写入

如果字符串之前没有写入，则数据将按以下方式写入：

```
| unsigned varint：字符串二进制大小 + 1 位：之前未写入 | 56 位：唯一哈希 | 3 位编码标志 + 字符串二进制 |
```

如果字符串二进制大小小于 `16` 字节，则将省略哈希以节省空间。如果调用者传递一个标志来禁用它，也可以省略唯一哈希。在这种情况下，格式将是：

```
| unsigned varint：字符串二进制大小 + 1 位：之前未写入 | 3 位编码标志 + 字符串二进制 |
```

#### 按引用写入

如果字符串之前已写入，数据将按以下方式写入：

```
| unsigned varint：已写入字符串 id + 1 位：之前已写入 |
```

## 值格式

### 基本类型

#### Bool

- 大小：1 字节
- 格式：0 表示“false”，1 表示“true”

#### Byte

- 大小：1 字节
- 格式：以纯字节形式写入。

#### Short int

- 大小：2 字节
- 字节顺序：小端序

#### char

- 大小：2 字节
- 字节顺序：小端序

#### 无符号整数

- 大小：1~5 字节
- 格式：每个字节中最高有效位 (MSB) 表示是否有下一个字节。如果第一位已设置，即 `b & 0x80 == 0x80`，则应读取下一个字节，直到下一个字节的第一位未设置。

#### 有符号整数

- 大小：1~5 字节
- 格式：首先通过 `(v << 1) ^ (v >> 31)` ZigZag 算法将数字转换为正无符号整数，然后将其编码为无符号整数。

#### 无符号长整型

- 大小：1~9 字节
- Apache Fury PVL（渐进可变长整型）编码：
- 正长整型格式：每个字节的第一位表示是否有下一个字节。如果第一位已设置
即 `b & 0x80 == 0x80`，则应读取下一个字节，直到第一位未设置。

#### 有符号长整型

- 大小：1~9 字节
- Apache Fury SLI（小长整型为 int）编码：
- 如果 long 在 [-1073741824, 1073741823] 内，则编码为 4 字节 int：`| little-endian: ((int) value) << 1 |`
- 否则写为 9 个字节：`| 0b1 | little-endian 8 字节长 |`
- Apache Fury PVL（渐进可变长长）编码：
- 首先通过 `(v << 1) ^ (v >> 63)` ZigZag 算法将数字转换为正无符号长整型以降低
小负数的成本，然后将其编码为无符号长整型。

#### Float

- 大小：4 字节
- 格式：通过 `Float.floatToRawIntBits` 将浮点数转换为 4 字节整数，然后按小端顺序写入二进制。

#### Double

- 大小：8 字节
- 格式：通过 `Double.doubleToRawLongBits` 将双精度数转换为 8 字节整数，然后按小端顺序写入二进制。

### String

格式：

```
| 标头：大小 << 2 | 2 位编码标志 | 二进制数据 |
```

- `size + encoding` 将连接为 long 并编码为无符号 var long。小 2 位用于
编码：
0 表示 `latin`，1 表示 `utf-16`，2 表示 `utf-8`。
- 根据编码对字符串二进制数据进行编码：`latin/utf-16/utf-8`。

选择哪种编码：

- 对于 JDK8：fury 在运行时检测 `latin`，如果字符串是 `latin` 字符串，则使用 `latin` 编码，否则
使用 `utf-16`。
- 对于 JDK9+：fury 在 `String` 对象中使用 `coder` 进行编码，将使用 `latin`/`utf-16` 进行编码。
- 如果字符串由 `utf-8` 编码，则 fury 将使用 `utf-8` 解码数据。但目前 fury 默认不为 java 启用
utf-8 编码。 fury 的跨语言字符串序列化默认使用 `utf-8`。

### Collection

> 所有集合序列化器都必须扩展 `AbstractCollectionSerializer`。

格式：

```
length(unsigned varint) | collection header | elements header | elements data
```

#### Collection header

- 对于 `ArrayList/LinkedArrayList/HashSet/LinkedHashSet`，这将是空的。

- 对于 `TreeSet`，这将是 `Comparator`
- 对于 `ArrayList` 的子类，这可能是额外的对象字段信息。

#### Elements header

在大多数情况下，所有集合元素都是相同类型且不为空，elements header 将对这些同类信息进行编码，以避免为每个元素编写信息的成本。具体来说，elements header 将对四种信息进行编码，每种信息使用一位：

- 如果跟踪元素引用，则使用 header 的第一位 `0b1` 来标记它。
- 如果集合有 null，则使用标头的第二位 `0b10` 来标记它。如果为此元素类型启用了引用跟踪，则此标记无效。
- 如果集合元素类型不是声明类型，则使用标头的第 3 位 `0b100` 来标记它。
- 如果集合元素类型不同，则使用标头的第 4 位 `0b1000` 来标记它。

默认情况下，所有位均未设置，这意味着所有元素都不会跟踪引用，所有元素都是相同类型，不为 null，并且实际元素是自定义类字段中声明的类型。

实现可以根据读取标头生成不同的反序列化代码，并从线性映射/列表中查找生成的代码。

#### 元素数据

基于元素标头，元素数据的序列化可能会跳过 `ref flag`/`null flag`/`element class info`。

可以以 `CollectionSerializer#write/read` 为例。

### 数组

#### 原始数组

原始数组被视为二进制缓冲区，序列化只会将数组大小的长度写入无符号整数，然后将整个缓冲区复制到流中。

此类序列化不会压缩数组。如果用户想要压缩原始数组，则需要为此类类型注册自定义序列化器。

#### 对象数组

对象数组使用集合格式进行序列化。对象组件类型将被视为集合元素通用类型。

### Map

> 所有 Map 序列化器都必须扩展 `AbstractMapSerializer`。

格式：

```
| 长度（无符号变量） | 映射头 | 键值对数据 |
```

#### 映射头

- 对于 `HashMap/LinkedHashMap`，这将是空的。

对于 `TreeMap`，这将是 `Comparator`
- 对于其他 `Map`，这可能是额外的对象字段信息。

#### 映射键值数据

映射迭代成本太高，Apache Fury 不会像以前的集合那样计算头，因为它引入了
[巨大开销](https://github.com/apache/fury/issues/925)。
用户可以使用 `MapFieldInfo` 注释提前提供头。否则 Apache Fury 将使用第一个键值对
乐观地预测头，如果预测在某些对失败，则更新块头。

Apache Fury 将逐块序列化映射，每个块最多有 127 对。

```
| 1 字节 | 1 字节 | 可变字节 |
+----------------+----------------+-----------------+
| 块大小：N | KV 标头 | N*2 个对象 |
```

KV 标头：

- 如果跟踪键引用，则使用标头的第一位 `0b1` 进行标记。
- 如果键为空，则使用标头的第二位 `0b10` 进行标记。如果为此键类型启用了引用跟踪，则此标记无效。
- 如果映射的键类型不同，则使用标头的第 3 位 `0b100` 进行标记。
- 如果映射的实际键类型不是声明的键类型，则使用标头的第 4 位 `0b1000` 进行标记。
- 如果跟踪值引用，则使用标头的第 5 位 `0b10000` 进行标记。
- 如果值为空，则使用标头的第 6 位 `0b100000` 进行标记。如果为该值类型启用了引用跟踪，则此标志无效。
- 如果映射的值类型不同，请使用第 7 位 `0b1000000` 标头来标记它。
- 如果映射的值类型不是声明的值类型，请使用标头的第 8 位 `0b10000000` 来标记它。

如果启用了流式写入，这意味着 Apache Fury 无法更新写入的 `chunk size`。在这种情况下，映射键值数据格式将是：

```
| 1 个字节 | 可变字节 |
+----------------+-----------------+
| KV 标头 | N*2 个对象 |
```

`KV 标头` 将是 java 中由 `MapFieldInfo` 标记的标头。实现可以根据读取标头生成不同的反序列化代码，并从线性映射/列表中查找生成的代码。

### Enum

枚举被序列化为无符号 `var int`。如果枚举值的顺序发生变化，反序列化的枚举值可能不是用户期望的值。在这种情况下，用户必须注册枚举序列化器，使其将枚举值写入枚举字符串并禁用唯一哈希。

### Object

对象表示的是 `pojo/struct/bean/record` 类型的对象。
对象将通过以任意顺序写入其字段数据来进行序列化。

根据模式兼容性，对象将具有不同的格式。

#### 字段顺序

字段将按以下顺序排列，每组字段都有自己的顺序：

- 原始字段：大小较大的类型先排，较小的排在后面，可变大小类型最后。
- 装箱原始字段：与原始字段的顺序相同
- 最终字段：相同类型放在一起，然后按字段名称字典顺序排序。
- 集合字段：与 final 字段的顺序相同
- 映射字段：与 final 字段的顺序相同
- 其他字段：与 final 字段的顺序相同

#### 模式一致

对象字段将使用以下格式逐个序列化：

```
原始字段值：
| var 字节 |
+----------------+
| 值数据 |
+----------------+
装箱字段值：
| 一个字节 | var 字节 |
+-----------+---------------+
| 空标志 | 字段值 |
+-----------+---------------+

具有引用跟踪的 final 类型的字段值：
| var 字节 | var 对象 |
+-----------+-------------+
| 引用元数据 | 值数据 |
+-----------+-------------+

没有引用跟踪的 final 类型的字段值：
| 一个字节 | var 对象 |
+-----------+-------------+
| 空标志 | 字段值 |
+-----------+-------------+
带有引用跟踪的非 final 类型的字段值：
| 一个字节 | var 字节 | var 对象 |
+-----------+-------------+-------------+
| 引用元数据 | 类元数据 | 值数据 |
+-----------+-------------+-------------+
不带引用跟踪的非 final 类型的字段值：
| 一个字节 | var 字节 | var 对象 |
+-----------+------------+------------+
| 空标志 | 类元数据 | 值数据 |
+-----------+------------+------------+
```

#### 模式演变

对于对象，模式演化具有与模式一致模式类似的格式，但以下情况除外：

- 对于此对象类型本身，“模式一致”将按 `id/name` 写入类，但“模式演化”模式也将写入类字段名称、类型和其他元数据，请参阅 [类元数据](#class-meta)。
- 还需要写入“最终自定义类型”的类元数据，因为对等方可能没有定义此类。

### 类

类将使用类元数据格式进行序列化。

## 实施指南

- 尝试在写入之前将多个字节合并为 `int/long` 写入，以减少内存 IO 和边界检查成本。
- 将多个字节读取为 `int/long`，然后拆分为多个字节，以减少内存 IO 和边界检查成本。
- 尝试使用一个 `varint/long` 将标志和长度一起写入，以节省一个字节的成本并减少内存 IO。
- 除非分支太多，否则条件分支的成本比内存 IO 成本要低。
